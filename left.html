<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Year Left</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <style>
      :root {
        /* Fixed sizes: dots never change size */
        --dot-size: 8px;
        --gap: 6px; /* updated by JS; only spacing changes */
      }

      /* App-specific layout (minimal; uses site styles) */
      .card {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 600px);
        height: 80vh; /* always 80% viewport height */
        min-width: 300px; /* enforce minimum width; grid/footer follow */
        border-radius: 28px;
        background: #f7f7f4;
        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start; /* grid top aligned */
        padding: 2rem;
        box-sizing: border-box;
        overflow: hidden; /* keep content inside */
        z-index: 1;
      }

      .grid {
        display: grid;
        grid-auto-rows: var(--dot-size);
        gap: var(--gap); /* updated by JS */
        margin: 0; /* positioned by card */
      }

      .dot {
        width: var(--dot-size);
        height: var(--dot-size);
        border-radius: 50%;
        background: #111110; /* visible in light mode too (site text color is dark) */
      }
      .dot.past { opacity: 0.5; }

      /* Bottom labels pinned to viewport edges (match site padding) */
      .bottom {
        position: absolute; /* inside the card */
        bottom: 1.25rem;
        left: 50%;
        transform: translateX(-50%);
        width: var(--footer-width, auto);
        display: flex;
        justify-content: space-between;
        align-items: center;
        opacity: 1; /* match full-opacity future dots */
        font-size: 0.95em;
        pointer-events: auto; /* allow clicking/tapping labels */
        z-index: 2;
      }

      /* Respect dark mode */
      @media (prefers-color-scheme: dark) {
        .dot { background: #EEEEEC; }
        .card {
          background: #141413;
          box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
        }
        .bottom { opacity: 1; }
      }
    </style>
  </head>
  <body>
    <div class="card">
      <div id="grid" class="grid" aria-label="Days of the year"></div>
      <div class="bottom">
        <span id="year"></span>
        <span id="right-info"></span>
      </div>
    </div>
    <button id="shareBtn" aria-label="Share snapshot" style="position:fixed; opacity:0.9; font-size:0.9em; background:transparent; border:none; cursor:pointer;">
      Share
    </button>

    <!-- html2canvas for snapshotting the card -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <script>
      (function () {
        const grid = document.getElementById('grid');
        const yearEl = document.getElementById('year');
        const infoEl = document.getElementById('right-info');
        const shareBtn = document.getElementById('shareBtn');

        const now = new Date();
        const y = now.getFullYear();
        const m = now.getMonth();
        const DAY_MS = 86400000;

        // Helpers
        const monthsShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const monthsFull  = ['January','February','March','April','May','June','July','August','September','October','November','December'];
        const ordinal = n => { const s = ["th","st","nd","rd"], v = n % 100; return n + (s[(v - 20) % 10] || s[v] || s[0]); };
        const formatDate = d => `${ordinal(d.getUTCDate())} ${monthsShort[d.getUTCMonth()]}, ${d.getUTCFullYear()}`;

        function yearState() {
          const startUTC = Date.UTC(y, 0, 1);
          const nextStartUTC = Date.UTC(y + 1, 0, 1);
          const totalDays = Math.round((nextStartUTC - startUTC) / DAY_MS);
          const todayIndex = Math.floor((Date.UTC(y, now.getMonth(), now.getDate()) - startUTC) / DAY_MS);
          const daysLeft = totalDays - (todayIndex + 1);
          return { labelLeft: String(y), startUTC, totalDays, todayIndex, cols: 15, rows: 25, daysLeft };
        }

        function monthState() {
          const startUTC = Date.UTC(y, m, 1);
          const nextStartUTC = Date.UTC(y, m + 1, 1);
          const totalDays = Math.round((nextStartUTC - startUTC) / DAY_MS);
          const todayIndex = Math.floor((Date.UTC(y, now.getMonth(), now.getDate()) - startUTC) / DAY_MS);
          const cols = 7;
          const rows = Math.ceil(totalDays / cols);
          const daysLeft = Math.max(0, totalDays - (todayIndex + 1));
          return { labelLeft: monthsFull[m], startUTC, totalDays, todayIndex, cols, rows, daysLeft };
        }

        let mode = 'year';
        let state = yearState();

        let showPercent = false; // right label mode

        function rightText() {
          if (!state) return '';
          if (showPercent) {
            const pct = state.totalDays ? Math.max(0, Math.min(100, Math.round((state.daysLeft / state.totalDays) * 100))) : 0;
            return pct + '% left';
          }
          return state.daysLeft + ' days left';
        }

        function renderGrid() {
          grid.innerHTML = '';
          grid.style.gridTemplateColumns = `repeat(${state.cols}, var(--dot-size))`;
          for (let i = 0; i < state.totalDays; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot' + (i <= state.todayIndex ? ' past' : '');
            const d = new Date(state.startUTC + i * DAY_MS);
            dot.title = formatDate(d);
            grid.appendChild(dot);
          }

          yearEl.textContent = state.labelLeft;
          infoEl.textContent = rightText();
          recalcGap();
        }

        // Hover handlers: show date of hovered dot; revert on leave
        grid.addEventListener('mouseover', (e) => {
          const t = e.target;
          if (t && t.classList && t.classList.contains('dot')) {
            infoEl.textContent = t.title;
          }
        });
        grid.addEventListener('mouseout', (e) => {
          const t = e.target;
          if (t && t.classList && t.classList.contains('dot')) {
            infoEl.textContent = rightText();
          }
        });

        // Tap/click on the left label to toggle between year and current month
        yearEl.addEventListener('click', () => {
          mode = mode === 'year' ? 'month' : 'year';
          state = mode === 'year' ? yearState() : monthState();
          renderGrid();
        });

        // Toggle right label between days left and % left
        infoEl.addEventListener('click', () => {
          showPercent = !showPercent;
          infoEl.textContent = rightText();
        });

        // Compute gap so the grid uses 90% of card height, never resizing dots
        function recalcGap() {
          const sample = grid.querySelector('.dot');
          if (!sample) return;
          const dotPx = sample.getBoundingClientRect().width || 8;

          const cols = state.cols, rows = state.rows;
          const card = document.querySelector('.card');
          const cs = getComputedStyle(card);
          const paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
          const paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
          const cardInnerW = Math.max(0, card.clientWidth - paddingX);
          const cardInnerH = Math.max(0, card.clientHeight - paddingY);

          const compute = (cCols, cRows, availW) => {
            const targetH = cardInnerH * 0.9;
            const gapH = (targetH - cRows * dotPx) / (cRows - 1 || 1);
            const gapW = (availW - cCols * dotPx) / (cCols - 1 || 1);
            const gap = Math.max(0, Math.min(gapW, gapH));
            const width = cCols * dotPx + (cCols - 1) * gap;
            return { gap, width };
          };

          // Compute how wide the YEAR grid would be in this viewport
          const yearMetrics = compute(15, 25, cardInnerW);

          // For month view, do not exceed the year width
          const allowedW = mode === 'month' ? Math.min(cardInnerW, yearMetrics.width) : cardInnerW;

          const current = compute(cols, rows, allowedW);
          grid.style.gap = current.gap + 'px';
          grid.style.width = current.width + 'px';
          document.documentElement.style.setProperty('--footer-width', current.width + 'px');
        }

        // Initial and on-resize calculations
        renderGrid();
        window.addEventListener('resize', recalcGap);
        window.addEventListener('orientationchange', recalcGap);

        // --- Share button positioning below card, bottom-right ---
        function positionShareButton() {
          const card = document.querySelector('.card');
          const rect = card.getBoundingClientRect();
          const btn = shareBtn;
          const margin = 8; // px gap below card
          btn.style.top = Math.round(rect.bottom + margin) + 'px';
          // Place right aligned to card's right edge
          const btnRect = btn.getBoundingClientRect();
          btn.style.left = Math.round(rect.right - btnRect.width) + 'px';
        }
        positionShareButton();
        window.addEventListener('resize', positionShareButton);
        window.addEventListener('orientationchange', positionShareButton);

        // --- Share: capture card and download ---
        async function shareSnapshot() {
          if (typeof window.html2canvas !== 'function') {
            alert('Sharing not available offline.');
            return;
          }

          // Build an offscreen 2000x2000 export with a square card inside
          const OUTER = 2000; // final image size
          const CARD = 1800;  // inner card a bit smaller
          const EXPORT_DOT = 16; // larger dots for export image

          const exportRoot = document.createElement('div');
          exportRoot.style.position = 'fixed';
          exportRoot.style.left = '-99999px';
          exportRoot.style.top = '0';
          exportRoot.style.width = OUTER + 'px';
          exportRoot.style.height = OUTER + 'px';
          const isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
          const siteBg = isDark ? '#222222' : '#FDFDFC'; // solid to avoid banding
          exportRoot.style.background = siteBg;
          exportRoot.style.overflow = 'hidden';

          const exportCard = document.createElement('div');
          exportCard.style.position = 'absolute';
          exportCard.style.left = Math.round((OUTER - CARD) / 2) + 'px';
          exportCard.style.top = Math.round((OUTER - CARD) / 2) + 'px';
          exportCard.style.width = CARD + 'px';
          exportCard.style.height = CARD + 'px';
          const cardComp = getComputedStyle(document.querySelector('.card'));
          exportCard.style.background = cardComp.backgroundColor || '#f7f7f4';
          exportCard.style.borderRadius = '80px';
          exportCard.style.boxShadow = 'none'; /* avoid corner artifacts */
          exportCard.style.overflow = 'hidden';
          exportCard.style.boxSizing = 'border-box';
          exportCard.style.border = isDark ? '2px solid rgba(255,255,255,0.08)' : '2px solid rgba(0,0,0,0.06)';
          exportCard.style.display = 'flex';
          exportCard.style.flexDirection = 'column';
          exportCard.style.alignItems = 'center';
          exportCard.style.justifyContent = 'flex-start';
          exportCard.style.padding = '120px';
          exportCard.style.boxSizing = 'border-box';

          const exportGrid = document.createElement('div');
          exportGrid.style.display = 'grid';
          exportGrid.style.gridTemplateColumns = `repeat(${state.cols}, ${EXPORT_DOT}px)`;
          exportGrid.style.margin = '0 auto';

          const exportFooter = document.createElement('div');
          exportFooter.style.position = 'absolute';
          exportFooter.style.bottom = '120px';
          exportFooter.style.display = 'flex';
          exportFooter.style.justifyContent = 'space-between';
          exportFooter.style.opacity = '1';
          exportFooter.style.fontFamily = getComputedStyle(document.body).fontFamily;
          exportFooter.style.fontSize = '36px';

          const leftLabel = document.createElement('span');
          leftLabel.textContent = state.labelLeft;
          const rightLabel = document.createElement('span');
          rightLabel.textContent = rightText();
          exportFooter.appendChild(leftLabel);
          exportFooter.appendChild(rightLabel);

          // Build dots for export
          for (let i = 0; i < state.totalDays; i++) {
            const dot = document.createElement('div');
            dot.style.width = EXPORT_DOT + 'px';
            dot.style.height = EXPORT_DOT + 'px';
            dot.style.borderRadius = '50%';
            const isPast = i <= state.todayIndex;
            dot.style.background = isDark ? '#EEEEEC' : '#111110';
            dot.style.opacity = isPast ? '0.5' : '1';
            exportGrid.appendChild(dot);
          }

          exportCard.appendChild(exportGrid);
          exportCard.appendChild(exportFooter);
          exportRoot.appendChild(exportCard);
          document.body.appendChild(exportRoot);

          // Compute spacing inside export card to center-top grid and align footer width
          (function calcExportLayout(){
            const dotPx = EXPORT_DOT; // fixed for export
            const padding = 120 * 2; // left+right and top+bottom equal
            const innerW = CARD - padding;
            const innerH = CARD - padding;

            const compute = (cols, rows, availW) => {
              const targetH = innerH * 0.9;
              const gapH = (targetH - rows * dotPx) / (rows - 1 || 1);
              const gapW = (availW - cols * dotPx) / (cols - 1 || 1);
              const gap = Math.max(0, Math.min(gapW, gapH));
              const gridW = cols * dotPx + (cols - 1) * gap;
              return { gap, gridW };
            };

            // Base: compute how wide the YEAR grid would be in this export card
            const yearBase = compute(15, 25, innerW);

            // Current grid (month or year) is capped to the year width
            const cols = state.cols, rows = state.rows;
            const capped = compute(cols, rows, Math.min(innerW, yearBase.gridW));

            exportGrid.style.gap = capped.gap + 'px';
            exportGrid.style.width = capped.gridW + 'px';

            // Footer matches grid width and is centered horizontally
            exportFooter.style.width = capped.gridW + 'px';
            const left = Math.round((CARD - capped.gridW) / 2);
            exportFooter.style.left = left + 'px';
          })();

          const canvas = await window.html2canvas(exportRoot, {
            backgroundColor: siteBg,
            scale: 1,
            width: OUTER,
            height: OUTER
          });

          // Cleanup the offscreen DOM
          exportRoot.remove();

          canvas.toBlob((blob) => {
            if (!blob) return;
            const a = document.createElement('a');
            const modeLabel = yearEl.textContent.trim();
            a.download = `left-${modeLabel.replace(/\s+/g,'-').toLowerCase()}.png`;
            a.href = URL.createObjectURL(blob);
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(a.href);
            a.remove();
          }, 'image/png');
        }
        shareBtn.addEventListener('click', shareSnapshot);
      })();
    </script>
  </body>
  </html>
