<!DOCTYPE html>

	


<html lang="en">
	<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" type="text/css" href="style.css">
	<link rel="shortcut icon" type="image/png" href="images/favicon.png"/>
	<title>now</title>




	</head>
	
	<body>

		<h1 class="title"><a class="titlelink" href="/">Cristian Rus</a> </h1>
			<p class="sub">design & human behaviour</p>



				<table id="animated-table">

                   
				  <tr>
				    <th>age</td>
				    <td><span id="counter"></span></td>
				  </tr>

				  <tr>
				    <th>location</td>
				    <td>
  <span id="randomLetters"></span>
 <!-- <span class="radar">
    <span class="center-dot"></span>
  </span>-->
</td>
				  </tr>
				  <tr>
				    <th>conditions</td>
				    <td><span id="weatherInfo"></span></td>
				  </tr>
				  
                  

                 <tr>
                    <th><br></td>
                    <td></td>
                  </tr>

				  <!--
				  <tr>
				    <th>workout</td>
				    <td id="last-item"> &#xf5c4;</td>
				  </tr>
				  -->

				  <tr>
				    <th>obsessed</td>
				    <td id="top-song"></td>
				  </tr>
				  
				  <tr>
				    <th>watched</td>
				    <td id="last-movie"></td>
				  </tr>
				  <tr>
				    <th>read</td>
				    <td id="last-book"></td>
				  </tr>
				  <tr>
				    <th>code</td>
				    <td id="code-info"></td>
				  </tr>
				  <tr>
				    <th>event</td>
				    <td id="calendar-info"></td>
				  </tr>

				  
			
				</table>





<script>
  // Function to generate a random letter
  function getRandomLetter() {
    const alphabet = 'abcdefghijklmnopqrstuvwxyz';
    return alphabet.charAt(Math.floor(Math.random() * alphabet.length));
  }

  // Function to update the random letters
  function updateRandomLetters() {
    let randomLetters = '';
    for (let i = 0; i < 13; i++) {
      randomLetters += getRandomLetter(); // All letters are lowercase
    }
    // Capitalize the first letter
    randomLetters = randomLetters.charAt(0).toUpperCase() + randomLetters.slice(1);
    document.getElementById('randomLetters').textContent = randomLetters;
  }

  // Change letters every 2 milliseconds
  const interval = setInterval(updateRandomLetters, 50);

  // After 4 seconds, change all letters to "Auckland"
  setTimeout(function() {
    clearInterval(interval); // Stop the interval
    document.getElementById('randomLetters').textContent = 'Wellington, NZ';
  }, 3000);

</script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        var text = "Your Original Text";
        var randomText = shuffle(text);
        document.querySelector('.pulse').setAttribute('data-random', randomText);
    });

    function shuffle(text) {
        var shuffledText = '';
        var chars = text.split('');
        var len = chars.length;
        for (var i = 0; i < len; i++) {
            if (Math.random() < 0.5) {
                shuffledText += String.fromCharCode(Math.floor(Math.random() * 26) + 97);
            } else {
                shuffledText += chars[i];
            }
        }
        return shuffledText;
    }
</script>



<script type="text/javascript">document.addEventListener("DOMContentLoaded", function() {
    // Get all table rows
    const rows = document.querySelectorAll("#animated-table tr");

    // Loop through each row and add a class to trigger the animation
    rows.forEach((row, index) => {
        setTimeout(() => {
            row.style.opacity = "1";
        }, index * 170); 
    });
});
</script>


<script>
    (function() {
        const lastFmApiKey = 'b1181111f4966c86cd00c3ef5fc59a55'; // Replace this with your Last.fm API key
        const username = 'cristianrus4'; // Replace this with your Last.fm username

        // Get the date 7 days ago in UNIX timestamp format
        const last7DaysTimestamp = Math.floor((new Date().getTime() - (7 * 24 * 60 * 60 * 1000)) / 1000);

        // API endpoint to get top tracks for a user in the last 7 days
        const apiUrl = `https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks&user=${username}&api_key=${lastFmApiKey}&format=json&limit=1&from=${last7DaysTimestamp}`;

        // Fetch the top track from the last 7 days
        fetch(apiUrl)
            .then(response => response.json())
            .then(data => {
                // Check if data contains tracks
                if (data && data.toptracks && data.toptracks.track && data.toptracks.track.length > 0) {
                    // Get the top track
                    const topTrack = data.toptracks.track[0];

                    // Extract track details
                    const artist = topTrack.artist.name;
                    const trackName = topTrack.name;
                    const playCount = topTrack.playcount;

                    // Display top track
                    const topSongElement = document.getElementById('top-song');
                    topSongElement.innerHTML = `
                         <em>${trackName}</em> by ${artist}
                    `;
                } else {
                    console.error('No top tracks found for the user in the last 7 days.');
                }
            })
            .catch(error => {
                console.error('Error fetching top tracks:', error);
            });
    })();
</script>























<div style="display: none;">

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M320 48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM125.7 175.5c9.9-9.9 23.4-15.5 37.5-15.5c1.9 0 3.8 .1 5.6 .3L137.6 254c-9.3 28 1.7 58.8 26.8 74.5l86.2 53.9-25.4 88.8c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l28.7-100.4c5.9-20.6-2.6-42.6-20.7-53.9L238 299l30.9-82.4 5.1 12.3C289 264.7 323.9 288 362.7 288H384c17.7 0 32-14.3 32-32s-14.3-32-32-32H362.7c-12.9 0-24.6-7.8-29.5-19.7l-6.3-15c-14.6-35.1-44.1-61.9-80.5-73.1l-48.7-15c-11.1-3.4-22.7-5.2-34.4-5.2c-31 0-60.8 12.3-82.7 34.3L57.4 153.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l23.1-23.1zM91.2 352H32c-17.7 0-32 14.3-32 32s14.3 32 32 32h69.6c19 0 36.2-11.2 43.9-28.5L157 361.6l-9.5-6c-17.5-10.9-30.5-26.8-37.9-44.9L91.2 352z"/></svg>

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M309.5 178.4L447.9 297.1c-1.6 .9-3.2 2-4.8 3c-18 12.4-40.1 20.3-59.2 20.3c-19.6 0-40.8-7.7-59.2-20.3c-22.1-15.5-51.6-15.5-73.7 0c-17.1 11.8-38 20.3-59.2 20.3c-10.1 0-21.1-2.2-31.9-6.2C163.1 193.2 262.2 96 384 96h64c17.7 0 32 14.3 32 32s-14.3 32-32 32H384c-26.9 0-52.3 6.6-74.5 18.4zM160 160A64 64 0 1 1 32 160a64 64 0 1 1 128 0zM306.5 325.9C329 341.4 356.5 352 384 352c26.9 0 55.4-10.8 77.4-26.1l0 0c11.9-8.5 28.1-7.8 39.2 1.7c14.4 11.9 32.5 21 50.6 25.2c17.2 4 27.9 21.2 23.9 38.4s-21.2 27.9-38.4 23.9c-24.5-5.7-44.9-16.5-58.2-25C449.5 405.7 417 416 384 416c-31.9 0-60.6-9.9-80.4-18.9c-5.8-2.7-11.1-5.3-15.6-7.7c-4.5 2.4-9.7 5.1-15.6 7.7c-19.8 9-48.5 18.9-80.4 18.9c-33 0-65.5-10.3-94.5-25.8c-13.4 8.4-33.7 19.3-58.2 25c-17.2 4-34.4-6.7-38.4-23.9s6.7-34.4 23.9-38.4c18.1-4.2 36.2-13.3 50.6-25.2c11.1-9.4 27.3-10.1 39.2-1.7l0 0C136.7 341.2 165.1 352 192 352c27.5 0 55-10.6 77.5-26.1c11.1-7.9 25.9-7.9 37 0z"/></svg>


<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M96 64c0-17.7 14.3-32 32-32h32c17.7 0 32 14.3 32 32V224v64V448c0 17.7-14.3 32-32 32H128c-17.7 0-32-14.3-32-32V384H64c-17.7 0-32-14.3-32-32V288c-17.7 0-32-14.3-32-32s14.3-32 32-32V160c0-17.7 14.3-32 32-32H96V64zm448 0v64h32c17.7 0 32 14.3 32 32v64c17.7 0 32 14.3 32 32s-14.3 32-32 32v64c0 17.7-14.3 32-32 32H544v64c0 17.7-14.3 32-32 32H480c-17.7 0-32-14.3-32-32V288 224 64c0-17.7 14.3-32 32-32h32c17.7 0 32 14.3 32 32zM416 224v64H224V224H416z"/></svg>


<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M160 48a48 48 0 1 1 96 0 48 48 0 1 1 -96 0zM126.5 199.3c-1 .4-1.9 .8-2.9 1.2l-8 3.5c-16.4 7.3-29 21.2-34.7 38.2l-2.6 7.8c-5.6 16.8-23.7 25.8-40.5 20.2s-25.8-23.7-20.2-40.5l2.6-7.8c11.4-34.1 36.6-61.9 69.4-76.5l8-3.5c20.8-9.2 43.3-14 66.1-14c44.6 0 84.8 26.8 101.9 67.9L281 232.7l21.4 10.7c15.8 7.9 22.2 27.1 14.3 42.9s-27.1 22.2-42.9 14.3L247 287.3c-10.3-5.2-18.4-13.8-22.8-24.5l-9.6-23-19.3 65.5 49.5 54c5.4 5.9 9.2 13 11.2 20.8l23 92.1c4.3 17.1-6.1 34.5-23.3 38.8s-34.5-6.1-38.8-23.3l-22-88.1-70.7-77.1c-14.8-16.1-20.3-38.6-14.7-59.7l16.9-63.5zM68.7 398l25-62.4c2.1 3 4.5 5.8 7 8.6l40.7 44.4-14.5 36.2c-2.4 6-6 11.5-10.6 16.1L54.6 502.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L68.7 398z"/></svg>


<!-- Script for the first RSS feed (Letterboxd) -->
<div id="last-movie">
    <!-- Last movie details will be inserted here -->
</div>

<script>
    (function() {
        // Proxy URL to fetch the RSS feed
        const proxyUrl = 'https://api.rss2json.com/v1/api.json?rss_url=';

        // Generate a random cache-busting parameter
        const cacheBuster = Date.now();

        // Fetch the RSS feed using the proxy with cache-busting parameter
        fetch(`${proxyUrl}${encodeURIComponent('https://letterboxd.com/cristianrus4/rss/')}&cacheBuster=${cacheBuster}`)
            .then(response => response.json())
            .then(data => {
                // Check if data contains items
                if (data.items && data.items.length > 0) {
                    // Get the last movie
                    const lastMovie = data.items[0];

                    // Extract movie details
                    const title = lastMovie.title;

                    // Display last movie watched
                    const lastMovieElement = document.getElementById('last-movie');
                    lastMovieElement.innerHTML = `${title}`;
                } else {
                    console.error('RSS feed data is empty or invalid');
                }
            })
            .catch(error => {
                console.error('Error fetching RSS feed:', error);
            });
    })();
</script>

<!-- Script for the second RSS feed (FetchRSS) -->
<div id="last-item">
    <!-- Last item details will be inserted here -->
</div>

<script>
    (function() {
    // Proxy URL to fetch the RSS feed
    const proxyUrl = 'https://api.rss2json.com/v1/api.json?rss_url=';

    // Fetch the RSS feed using the proxy
    fetch(proxyUrl + encodeURIComponent('https://fetchrss.com/rss/66176ae481670c3fad16444266176aac58588e69ae5b30a2.xml'))
        .then(response => response.json())
        .then(data => {
            // Check if data contains items
            if (data.items && data.items.length > 0) {
                // Get the last item
                const lastItem = data.items[0];

                // Extract item details
                const title = lastItem.title.toLowerCase(); // Convert title to lowercase
                let description = lastItem.description.replace(/<[^>]*>?/gm, ''); // Remove HTML tags from description
                description = description.toLowerCase(); // Convert description to lowercase
                const pubDate = new Date(lastItem.pubDate);

                // Remove unwanted words from description
                const unwantedWords = ["pool", "afternoon", "morning", "evening", "lunch", "night", "wednesday", "friday", "monday", "saturday"];
                unwantedWords.forEach(word => {
                    description = description.replace(new RegExp(word, 'gi'), '');
                });

                // Remove "(Feed generated with FetchRSS)"
                description = description.replace("(feed generated with fetchrss)", "").trim();

                // Convert time to total minutes
                let totalMinutes;
                const timeParts = description.trim().split(":");
                if (timeParts.length === 3) {
                    const hours = parseInt(timeParts[0]);
                    const minutes = parseInt(timeParts[1]);
                    const seconds = parseInt(timeParts[2]);
                    totalMinutes = hours * 60 + minutes + Math.round(seconds / 60);
                } else if (timeParts.length === 2) {
                    const minutes = parseInt(timeParts[0]);
                    const seconds = parseInt(timeParts[1]);
                    totalMinutes = minutes + Math.round(seconds / 60);
                } else {
                    totalMinutes = 0; // Set a default value if time format is unexpected
                }

                // Display last item with time converted to total minutes
                const lastItemElement = document.getElementById('last-item');
                lastItemElement.innerHTML = `
                    ${title}
                `;
            } else {
                console.error('RSS feed data is empty or invalid');
            }
        })
        .catch(error => {
            console.error('Error fetching RSS feed:', error);
        });
})();

</script>


<!-- Script for the third RSS feed (Goodreads) -->
<div id="last-book">
    <!-- Last book details will be inserted here -->
</div>
<script>
        (function() {
            // Proxy URL to fetch the RSS feed
            const proxyUrl = 'https://api.rss2json.com/v1/api.json?rss_url=';

            // Fetch the RSS feed using the proxy
            fetch(proxyUrl + encodeURIComponent('https://www.goodreads.com/review/list_rss/74821928?key=camdfkmNuO8PqylPKlVe_AckSkL5KnbljWIRS8Dd_HO_Nq_m&shelf=read'))
                .then(response => response.json())
                .then(data => {
                    // Check if data contains items
                    if (data.items && data.items.length > 0) {
                        // Find the most recent book by comparing publication dates
                        let mostRecentBook = data.items[0];
                        data.items.forEach(item => {
                            if (new Date(item.pubDate) > new Date(mostRecentBook.pubDate)) {
                                mostRecentBook = item;
                            }
                        });

                        // Extract book details
                        const title = mostRecentBook.title;
                        let author = '';

                        // Search for author information in the description
                        const description = mostRecentBook.description;
                        const authorMatch = description.match(/author:\s*(.*?)<br/);
                        if (authorMatch && authorMatch.length === 2) {
                            author = authorMatch[1];
                        }

                        // Display last book read
                        const lastBookElement = document.getElementById('last-book');
                        lastBookElement.innerHTML = `<em>${title}</em> by ${author}`;
                    } else {
                        console.error('RSS feed data is empty or invalid');
                    }
                })
                .catch(error => {
                    console.error('Error fetching RSS feed:', error);
                });
        })();
    </script>

<!-- Script for GitHub activity -->
<script>
    (function() {
        const apiUrl = 'https://api.github.com/users/cristianrus4/events/public';

        fetch(apiUrl)
            .then(response => response.json())
            .then(events => {
                if (!events || events.length === 0) {
                    document.getElementById('code-info').textContent = 'No activity found.';
                    return;
                }

                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const firstOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

                // Sort events by created_at descending
                events.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                // 1. Last activity date
                const lastActivityDate = new Date(events[0].created_at);
                let lastActivityText = '';
                const daysDiff = Math.floor((now - lastActivityDate) / (1000 * 60 * 60 * 24));
                
                if (daysDiff === 0) {
                    lastActivityText = 'today';
                } else if (daysDiff === 1) {
                    lastActivityText = 'yesterday';
                } else {
                    lastActivityText = lastActivityDate.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric' 
                    });
                }

                // 2. Active days this month
                const monthEvents = events.filter(e => {
                    const eventDate = new Date(e.created_at);
                    return eventDate >= firstOfMonth && eventDate <= now;
                });

                const activeDays = new Set(
                    monthEvents.map(e => {
                        const d = new Date(e.created_at);
                        return d.toISOString().slice(0, 10);
                    })
                ).size;

                const daysSoFar = now.getDate();

                // 3. Pushes this month
                const pushes = monthEvents.filter(e => e.type === 'PushEvent').length;

                // 4. Closed issues this month
                const closedIssues = monthEvents.filter(e => 
                    e.type === 'IssuesEvent' && 
                    e.payload && 
                    e.payload.action === 'closed'
                ).length;

                // Build the display text
                let displayText = `Worked <strong>${lastActivityText}</strong> last time`;
                
                if (activeDays > 0) {
                    displayText += ` and has been active <strong>${activeDays} out of ${daysSoFar} days</strong> this month`;
                }
                
                const parts = [];
                if (pushes > 0) {
                    parts.push(`Pushing <strong>${pushes} time${pushes !== 1 ? 's' : ''}</strong>`);
                }
                if (closedIssues > 0) {
                    parts.push(`closing <strong>${closedIssues} issue${closedIssues !== 1 ? 's' : ''}</strong>`);
                }
                
                if (parts.length > 0) {
                    displayText += '. ' + parts.join(' and ') + '.';
                } else if (activeDays > 0) {
                    displayText += '.';
                } else {
                    displayText += '.';
                }

                document.getElementById('code-info').innerHTML = displayText;
            })
            .catch(error => {
                console.error('Error fetching GitHub events:', error);
                document.getElementById('code-info').textContent = 'Unable to fetch activity.';
            });
    })();
</script>

<!-- Script for Google Calendar -->
<script>
    (function() {
        // Using the public calendar URL
        const calendarUrl = 'https://calendar.google.com/calendar/ical/559150518df79c732a264564f6ec6fa545e0ef5136a2b6d43054e52e25b2a86f%40group.calendar.google.com/public/basic.ics';
        
        // Use a CORS proxy if needed
        const proxyUrl = 'https://api.allorigins.win/raw?url=';
        const fetchUrl = proxyUrl + encodeURIComponent(calendarUrl);

        function parseICalDate(dateStr) {
            if (!dateStr) return null;
            
            // Remove any whitespace
            dateStr = dateStr.trim();
            
            // UTC format: 20240119T110000Z
            if (dateStr.includes('T') && dateStr.endsWith('Z')) {
                const d = dateStr;
                return new Date(
                    d.substring(0, 4) + '-' +
                    d.substring(4, 6) + '-' +
                    d.substring(6, 8) + 'T' +
                    d.substring(9, 11) + ':' +
                    d.substring(11, 13) + ':' +
                    d.substring(13, 15) + 'Z'
                );
            } 
            // Local time format: 20230603T110000 (with or without seconds)
            else if (dateStr.includes('T')) {
                const d = dateStr;
                const datePart = d.substring(0, 8);
                const timePart = d.substring(9);
                
                // Handle with seconds (15 chars) or without (13 chars)
                if (timePart.length >= 6) {
                    const hours = timePart.substring(0, 2);
                    const minutes = timePart.substring(2, 4);
                    const seconds = timePart.length >= 6 ? timePart.substring(4, 6) : '00';
                    return new Date(
                        datePart.substring(0, 4) + '-' +
                        datePart.substring(4, 6) + '-' +
                        datePart.substring(6, 8) + 'T' +
                        hours + ':' + minutes + ':' + seconds
                    );
                }
            } 
            // Date only: 20230310
            else if (dateStr.length === 8) {
                const d = dateStr;
                return new Date(
                    d.substring(0, 4) + '-' +
                    d.substring(4, 6) + '-' +
                    d.substring(6, 8)
                );
            }
            
            return null;
        }

        fetch(fetchUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to fetch calendar');
                }
                return response.text();
            })
            .then(icsText => {
                // Parse iCal format
                const events = [];
                const lines = icsText.split(/\r?\n/);
                let currentEvent = null;
                let inEvent = false;
                let lastKey = '';

                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i];
                    
                    if (line.startsWith('BEGIN:VEVENT')) {
                        inEvent = true;
                        currentEvent = {};
                        lastKey = '';
                    } else if (line.startsWith('END:VEVENT')) {
                        if (currentEvent && currentEvent.DTSTART && currentEvent.SUMMARY) {
                            events.push(currentEvent);
                        }
                        inEvent = false;
                        currentEvent = null;
                        lastKey = '';
                    } else if (inEvent && currentEvent) {
                        // Handle multi-line values (lines starting with space)
                        if (line.startsWith(' ') && lastKey) {
                            currentEvent[lastKey] += line.substring(1);
                        } else {
                            const colonIndex = line.indexOf(':');
                            if (colonIndex > 0) {
                                const key = line.substring(0, colonIndex);
                                const value = line.substring(colonIndex + 1);
                                
                                // Handle parameters (e.g., DTSTART;TZID=Pacific/Auckland:20230603T110000)
                                const keyParts = key.split(';');
                                const cleanKey = keyParts[0];
                                
                                if (cleanKey === 'DTSTART') {
                                    currentEvent.DTSTART = value;
                                    lastKey = 'DTSTART';
                                } else if (cleanKey === 'DTEND') {
                                    currentEvent.DTEND = value;
                                    lastKey = 'DTEND';
                                } else if (cleanKey === 'SUMMARY') {
                                    currentEvent.SUMMARY = value;
                                    lastKey = 'SUMMARY';
                                } else if (cleanKey === 'LOCATION') {
                                    currentEvent.LOCATION = value;
                                    lastKey = 'LOCATION';
                                } else {
                                    lastKey = '';
                                }
                            }
                        }
                    }
                }

                // Filter events that are before current time and sort by date descending
                const now = new Date();
                const pastEvents = events
                    .map(event => {
                        const eventDate = parseICalDate(event.DTSTART);
                        return { ...event, parsedDate: eventDate };
                    })
                    .filter(event => event.parsedDate && event.parsedDate < now)
                    .sort((a, b) => b.parsedDate - a.parsedDate); // Most recent first

                if (pastEvents.length > 0) {
                    const lastEvent = pastEvents[0];
                    const eventDate = lastEvent.parsedDate;
                    
                    // Format date
                    const dateStr = eventDate.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric',
                        year: eventDate.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
                    });
                    
                    // Format time if available
                    let timeStr = '';
                    if (lastEvent.DTSTART && lastEvent.DTSTART.includes('T')) {
                        timeStr = eventDate.toLocaleTimeString('en-US', { 
                            hour: 'numeric', 
                            minute: '2-digit',
                            hour12: true
                        });
                    }
                    
                    let displayText = `<strong>${lastEvent.SUMMARY}</strong>`;
                    if (dateStr) {
                        displayText += ` on ${dateStr}`;
                    }
                    if (timeStr) {
                        displayText += ` at ${timeStr}`;
                    }
                    if (lastEvent.LOCATION) {
                        // Clean up location (remove escaped commas)
                        const location = lastEvent.LOCATION.replace(/\\,/g, ',');
                        displayText += ` (${location})`;
                    }
                    
                    document.getElementById('calendar-info').innerHTML = displayText;
                } else {
                    document.getElementById('calendar-info').textContent = 'No past events found.';
                }
            })
            .catch(error => {
                console.error('Error fetching calendar:', error);
                document.getElementById('calendar-info').textContent = 'Unable to fetch calendar.';
            });
    })();
</script>




<p>Years: <span id="counter"></span></p>



 <p>Location: <span class="pulse">Wellington, NZ</span></p>

<div id="weatherInfo"></div>


  

	
	<iframe allow="autoplay *; encrypted-media *; fullscreen *; clipboard-write" frameborder="0" height="450" style="width:100%;max-width:660px;overflow:hidden;border-radius:10px;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/nz/playlist/heavy-rotation-mix/pl.pm-20e9f373919da0803092f207f602b9a3"></iframe>




<script>
    // Function to fetch weather data
    function getWeather() {
        // Your OpenWeatherMap API key
        const apiKey = "1def22ce2b0dcb06bec08ed98beda671";
        // City to get weather for
        const city = "Wellington,nz";
        // API endpoint
        const apiUrl = `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;

        // Fetch weather data
        fetch(apiUrl)
            .then(response => response.json())
            .then(data => {
                // Extract weather condition and temperature
                const weatherCondition = data.weather[0].description;
                const temperature = Math.floor(data.main.temp); // Round down temperature

                // Display weather information
                const weatherInfoDiv = document.getElementById("weatherInfo");
                weatherInfoDiv.innerHTML = `${weatherCondition} and ${temperature}Â°C`;
            })
            .catch(error => {
                console.error('Error fetching weather data:', error);
                // Display error message
                const weatherInfoDiv = document.getElementById("weatherInfo");
                weatherInfoDiv.innerHTML = "<p>Failed to fetch weather data. Please try again later.</p>";
            });
    }

    // Call the function to fetch weather when the page loads
    window.onload = getWeather;
</script>



<script>
// Function to calculate the time difference in years with 9 decimal places
function getTimeDifference(startDate) {
    var currentDate = new Date();
    var difference = currentDate - startDate;

    var years = difference / (1000 * 60 * 60 * 24 * 365.25); // Convert milliseconds to years
    years = parseFloat(years.toFixed(9)); // Round to 9 decimal places

    return years;
}

// Function to update the counter
function updateCounter() {
    var startDate = new Date(1994, 3, 22, 16, 4, 4); // 7am, April 22, 1994
    var difference = getTimeDifference(startDate);

    var counterElement = document.getElementById('counter');
    counterElement.textContent = difference;

    // Update the counter every millisecond
    setTimeout(updateCounter, 1);
}

// Initial update
updateCounter();
</script>


</div>

	</body>

	

</html>
	
